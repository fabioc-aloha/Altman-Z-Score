"""
Altman Z-Score Text Reporting Utilities

This module provides functions to generate, format, and save Altman Z-Score text reports and tables.
All output in this module must use the logging module; direct print statements are prohibited.

Key Features:
- Generates comprehensive, theory-informed financial health analysis reports using the Altman Z-Score framework.
- Integrates quantitative diagnostics, turnaround management theory, and stakeholder recommendations.
- Produces Markdown-formatted reports, tables, and appendices with data provenance and quality summaries.
- Handles company logo fetching, chart embedding, and LLM-generated commentary.
- Designed for modularity, maintainability, and robust error handling.
"""

import os
import json
import re
import pandas as pd
import tabulate
from datetime import datetime
from altman_zscore.computation.constants import MODEL_COEFFICIENTS, Z_SCORE_THRESHOLDS
from altman_zscore.utils.paths import get_output_dir
import logging
import shutil
from PIL import Image
from src.altman_zscore.api import FinnhubClient

from altman_zscore.utils.colors import Colors
from altman_zscore.models.enums import CompanyStage
from altman_zscore.models.model_thresholds import ModelCoefficients, ModelThresholds, TechCalibration


def _get_report_intro_and_title(context_info):
    """Build the report title and introduction section for the Z-Score analysis report.

    Args:
        context_info (dict): Contextual information about the analysis, including ticker and company info.

    Returns:
        list: List of strings representing the title and introduction lines.
    """
    intro_lines = [
        # "---",
        # "## Introduction",
        "This report provides a comprehensive, theory-informed financial health analysis of the selected company using the Altman Z-Score framework. It integrates quantitative diagnostics, turnaround management theory, and stakeholder recommendations, with all findings and recommendations grounded in referenced academic and industry sources. The analysis is generated by an expert LLM-driven pipeline, ensuring transparency, reproducibility, and robust source attribution.",
        "",
        "**Author:** Fabio Correa",
        "",
        "**Source Attribution:** This report and analysis pipeline are generated using the open-source Altman Z-Score Analysis project, available at [https://github.com/fabioc-aloha/Altman-Z-Score](https://github.com/fabioc-aloha/Altman-Z-Score).",
        "",
        "**License:** This software is distributed under the Attribution Non-Commercial License (MIT-based). See the LICENSE file for details.",
        "",
        "**Disclaimer**: The developer disclaims any responsibility for the accuracy, completeness, or consequences of the analysis and information provided by this software. All results are for informational purposes only and should not be relied upon for financial, investment, or legal decisions.",
        # "---",
        "",
    ]
    company_name = None
    try:
        import yfinance as yf
        yf_ticker = yf.Ticker(context_info["Ticker"]) if context_info and "Ticker" in context_info else None
        if yf_ticker:
            info = yf_ticker.info
            company_name = info.get("shortName") or info.get("longName")
    except Exception:
        company_name = None
    if not company_name and context_info and "Ticker" in context_info:
        company_name = context_info["Ticker"].upper()
    if company_name and context_info and "Ticker" in context_info:
        title = f"# Altman Z-Score Analysis Report: {company_name} ({context_info['Ticker'].upper()})"
    else:
        title = "# Altman Z-Score Analysis Report"
    return [title, ""] + intro_lines


def _get_script_version():
    """Return the script version string for inclusion in the report.

    Returns:
        str: Script version string, or 'unknown' if unavailable.
    """
    try:
        from main import __version__ as pipeline_version
    except ImportError:
        pipeline_version = "unknown"
    return f"**Script Version:** v{pipeline_version}\n"


def _get_context_section(context_info):
    """Build the context section describing analysis context and model selection criteria.

    Args:
        context_info (dict): Contextual information about the analysis.

    Returns:
        list: List of strings for the context section.
    """
    lines = ["## Analysis Context and Z-Score Model Selection Criteria\n"]
    if context_info:
        industry_val = context_info.get("Industry")
        sic_val = context_info.get("SIC Code")
        if industry_val and sic_val and industry_val != "Unknown":
            lines.append(f"- **Industry:** {industry_val} (SIC {sic_val})")
        else:
            lines.append(f"- **Industry:** {industry_val or sic_val}")
        for k, v in context_info.items():
            if k in ("Industry", "SIC Code"):
                continue
            lines.append(f"- **{k}:** {v}")
        lines.append("")
    return lines


def _get_model_label_and_overrides(df, model, context_info):
    """Determine the model label and collect any model/threshold overrides for reporting.

    Args:
        df (pd.DataFrame): DataFrame containing Z-Score results and possible overrides.
        model (str): Model identifier.
        context_info (dict): Contextual information about the analysis.

    Returns:
        tuple: (model_label, model_name, override_lines)
            model_label (str): Human-readable model label.
            model_name (str): Model identifier.
            override_lines (list): List of strings describing overrides.
    """
    MODEL_LABELS = {
        "original": "Original Z-Score (Public Manufacturing, 1968)",
        "private": "Z′-Score (Private Manufacturing, 1983)",
        "private_mfg": "Z′-Score (Private Manufacturing, 1983)",
        "private_service": "Zʺ-Score (Private Non-Manufacturing, Book Equity, 1995)",
        "service": "Zʺ-Score (Public Non-Manufacturing, 1995)",
        "emerging": "EM-Score (Emerging Markets, mid-1990s)",
    }
    override_lines = []
    override_context = None
    if hasattr(df, "zscore_results") and df.zscore_results:
        override_context = getattr(df.zscore_results[0], "override_context", None)
        if override_context:
            override_lines.append("### Model/Threshold Overrides and Assumptions\n")
            for k, v in override_context.items():
                override_lines.append(f"- **{k}: {v}")
            override_lines.append("")
    elif "override_context" in df.columns:
        oc = df["override_context"].iloc[0]
        if oc:
            override_context = oc
            override_lines.append("### Model/Threshold Overrides and Assumptions\n")
            for k, v in oc.items():
                override_lines.append(f"- **{k}: {v}")
            override_lines.append("")
    model_name = None
    if hasattr(df, 'zscore_results') and df.zscore_results and hasattr(df.zscore_results[0], 'model'):
        model_name = df.zscore_results[0].model
    elif 'model' in df.columns:
        model_name = df['model'].iloc[0]
    else:
        model_name = str(model).lower()
    if not model_name:
        model_name = 'original'
    model_label = MODEL_LABELS.get(str(model_name).lower(), str(model_name))
    # Patch context_info if needed
    if context_info is not None:
        for idx, line in enumerate(override_lines):
            if line.strip().startsWith('- **Model:**'):
                override_lines[idx] = f'- **Model:** {model_label} ({model_name})'
                break
    return model_label, model_name, override_lines


def _get_formula_and_threshold_section(model_name):
    """Build the Z-Score formula and threshold section for the report.

    Args:
        model_name (str): Model identifier.

    Returns:
        tuple: (formula_lines, threshold_lines, x_cols)
            formula_lines (list): Lines describing the formula.
            threshold_lines (list): Lines describing thresholds.
            x_cols (list): List of X variable names used in the model.
    """
    formula_lines = []
    threshold_lines = []
    x_labels = []
    x_cols = []
    coeffs = MODEL_COEFFICIENTS.get(model_name, MODEL_COEFFICIENTS['original'])
    thresholds = Z_SCORE_THRESHOLDS.get(model_name, Z_SCORE_THRESHOLDS['original'])
    coeff_map = [
        ("X1", coeffs.get("A", 0), "(Current Assets - Current Liabilities) / Total Assets"),
        ("X2", coeffs.get("B", 0), "Retained Earnings / Total Assets"),
        ("X3", coeffs.get("C", 0), "EBIT / Total Assets"),
        ("X4", coeffs.get("D", 0), "Equity / Total Liabilities"),
        ("X5", coeffs.get("E", 0), "Sales / Total Assets"),
    ]
    terms = []
    for x, coeff, desc in coeff_map:
        if coeff != 0:
            terms.append(f"{coeff}*{x}")
            x_labels.append((x, desc))
            x_cols.append(x)
    formula_str = "Z = " + " + ".join(terms)
    formula_lines.append(f"## Z-Score Formula Used\n")
    formula_lines.append(formula_str)
    for x, desc in x_labels:
        formula_lines.append(f"- {x} = {desc}")
    formula_lines.append("")
    threshold_lines.append("**Thresholds:**")
    threshold_lines.append(f"- Safe Zone: > {thresholds['safe']}")
    threshold_lines.append(f"- Grey Zone: > {thresholds['distress']} and <= {thresholds['safe']}")
    threshold_lines.append(f"- Distress Zone: <= {thresholds['distress']}")
    # threshold_lines.append("")
    return formula_lines, threshold_lines, x_cols


def _get_missing_fields_section(df):
    """Generate a warning section for missing fields in the data.

    Args:
        df (pd.DataFrame): DataFrame containing Z-Score results and missing field info.

    Returns:
        list: List of warning strings if missing fields are detected, else empty list.
    """
    lines = []
    if hasattr(df, "missing_fields") and df.missing_fields:
        lines.append(
            "> **Warning:** The following required fields were missing for one or more quarters: "
            + ", ".join(sorted(set(df.missing_fields)))
            + ". Z-Score components for these fields are omitted or estimated. Interpret results with caution."
        )
        lines.append("")
    elif hasattr(df, "zscore_results") and df.zscore_results:
        missing = set()
        for res in df.zscore_results:
            if hasattr(res, "missing_fields") and res.missing_fields:
                missing.update(res.missing_fields)
        if missing:
            lines.append(
                "> **Warning:** The following required fields were missing for one or more quarters: "
                + ", ".join(sorted(missing))
                + ". Z-Score components for these fields are omitted or estimated. Interpret results with caution."
            )
            lines.append("")
    return lines


def _format_number_millions(val):
    """Format a numeric value as millions with one decimal place.

    Args:
        val (float or str): Value to format.

    Returns:
        str: Formatted value as string, or empty string if input is None/empty.
    """
    try:
        if val is None or val == "":
            return ""
        val = float(val)
        val_m = val / 1_000_000
        return f"{val_m:,.1f}"
    except ValueError:
        return str(val)


def _get_field_mapping_table(df):
    """Generate a Markdown table mapping canonical fields to raw fields and values.

    Args:
        df (pd.DataFrame): DataFrame with field mapping info per quarter.

    Returns:
        str: Markdown-formatted table as a string.
    """
    mapping_rows = []
    mapping_header = ["Quarter", "Canonical Field", "Mapped Raw Field", "Value (USD millions)"]
    for idx, row in enumerate(df.iterrows()):
        _, row = row
        q = row.get("quarter_end")
        q_str = str(q)
        try:
            dt = pd.to_datetime(q)
            q_str = f"{dt.year} Q{((dt.month-1)//3)+1}"
        except (ValueError, TypeError):
            pass
        field_mapping = row.get("field_mapping")
        if isinstance(field_mapping, str):
            try:
                field_mapping = json.loads(field_mapping)
            except Exception:
                field_mapping = {}
        if not isinstance(field_mapping, dict):
            field_mapping = {}
        for canon, mapping in field_mapping.items():
            mapped_raw = mapping.get("mapped_raw_field")
            val = mapping.get("value")
            mapping_rows.append([
                q_str,
                canon,
                mapped_raw if mapped_raw is not None else "",
                _format_number_millions(val),
            ])
        if idx < len(df) - 1:
            mapping_rows.append(["---", "---", "---", "---"])
    return tabulate.tabulate(mapping_rows, headers=mapping_header, tablefmt="github")


def _get_zscore_component_table(df, x_cols):
    """Generate a Markdown table of Z-Score components and diagnostics by quarter.

    Args:
        df (pd.DataFrame): DataFrame with Z-Score results.
        x_cols (list): List of X variable names to include as columns.

    Returns:
        str: Markdown-formatted table as a string.
    """
    rows = []
    for _, row in df.iterrows():
        q = row.get("quarter_end")
        q_str = str(q)
        try:
            dt = pd.to_datetime(q)
            q_str = f"{dt.year} Q{((dt.month-1)//3)+1}"
        except (ValueError, TypeError):
            pass
        z = row.get("zscore")
        comps = row.get("components")
        diag = row.get("diagnostic")
        if isinstance(comps, str):
            try:
                comps = json.loads(comps)
            except Exception:
                comps = {}
        if not isinstance(comps, dict):
            comps = {}
        row_vals = [q_str]
        for x in x_cols:
            val = comps.get(x)
            row_vals.append(f"{val:.3f}" if val is not None else "")
        row_vals.append(f"{z:.3f}" if z is not None else "")
        row_vals.append(diag or "")
        rows.append(row_vals)
    header = ["Quarter"] + x_cols + ["Z-Score", "Diagnostic"]
    if "consistency_warning" in df.columns:
        header.append("Consistency Warning")
        for i, (_, row) in enumerate(df.iterrows()):
            warning = row.get("consistency_warning")
            rows[i].append(warning if warning else "No issues")
    return tabulate.tabulate(rows, headers=header, tablefmt="github")


def _get_chart_md(context_info, out_base):
    """Generate Markdown for embedding the Z-Score and price trend chart in the report.

    Args:
        context_info (dict): Contextual information including ticker.
        out_base (str): Output base name for report files.

    Returns:
        str or None: Markdown image link if chart is available, else None.
    """
    ticker = context_info.get("Ticker") if context_info else None
    out_path = None
    if out_base:
        out_path = get_output_dir(relative_path=f"{out_base}_zscore_full_report.md")
    chart_md = None
    if ticker and out_path:
        github_chart_path = f"zscore_{ticker}_trend.png"
        local_chart_path = os.path.abspath(os.path.join("output", ticker, f"zscore_{ticker}_trend.png"))
        out_dir = os.path.abspath(os.path.dirname(out_path))
        chart_dir = os.path.dirname(local_chart_path)
        if out_dir == chart_dir:
            chart_md = f"\n![Z-Score and Price Trend Chart]({github_chart_path})\n"
        else:
            rel_chart_path = os.path.relpath(local_chart_path, out_dir).replace("\\", "/")
            chart_md = f"\n![Z-Score and Price Trend Chart]({rel_chart_path})\n"
        chart_md += "\n"
        chart_md += f"*Figure: Z-Score and stock price trend for {ticker.upper()} (see output folder for full-resolution image)*\n"
    return chart_md


def get_key_financial_ratios(quarters, fin_raw=None):
    """Compute key financial ratios for each period and format the latest period's ratios.

    Args:
        quarters (list): List of dicts, each representing a quarter's financials.
        fin_raw (dict, optional): Raw financial data for fallback lookup.

    Returns:
        tuple: (ratio_header, ratio_rows, latest_str)
            ratio_header (list): Column headers for the ratios table.
            ratio_rows (list): List of rows (each a list of strings) for the table.
            latest_str (str): Formatted string for the latest period's ratios.
    """
    def get_any(d, keys):
        for k in keys:
            if k in d and d[k] not in (None, ""):
                return d[k]
        return None
    ratio_rows = []
    ratio_header = [
        "Period End", "Current Ratio", "Quick Ratio", "Debt/Equity", "Gross Margin", "Net Margin", "ROA", "ROE"
    ]
    latest_ratio_dict = None
    for q in quarters:
        try:
            ca = float(q.get("current_assets", 0))
            cl = float(q.get("current_liabilities", 0))
            inv = float(q.get("inventory", 0) or 0)
            ta = float(q.get("total_assets", 0))
            tl = float(q.get("total_liabilities", 0))
            eq = ta - tl
            period = q.get("period_end")
            ni = get_any(q, ["net_income", "Net Income", "netIncome", "net_income_common_stockholders"]) or 0
            gp = get_any(q, ["gross_profit", "Gross Profit", "grossProfit"]) or 0
            # If missing, try to get from fin_raw
            if fin_raw and (not ni or float(ni) == 0 or ni == "0.0") and fin_raw.get("income_statement"):
                period_key = None
                for k in fin_raw["income_statement"].keys():
                    if str(period)[:10] in k:
                        period_key = k
                        break
                if period_key:
                    ni = get_any(fin_raw["income_statement"][period_key], [
                        "Net Income", "Net Income Common Stockholders", "Net Income Including Noncontrolling Interests", "Net Income From Continuing And Discontinued Operation", "net_income", "netIncome", "Net Income Continuous Operations"
                    ]) or 0
                    gp = get_any(fin_raw["income_statement"][period_key], ["Gross Profit", "gross_profit", "grossProfit"]) or 0
            ni = float(ni) if ni not in (None, "") else 0
            gp = float(gp) if gp not in (None, "") else 0
            sales = float(q.get("sales", 0))
            current_ratio = ca / cl if cl else None
            quick_ratio = (ca - inv) / cl if cl else None
            debt_equity = tl / eq if eq else None
            gross_margin = gp / sales if sales else None
            net_margin = ni / sales if sales else None
            roa = ni / ta if ta else None
            roe = ni / eq if eq else None
            if period:
                try:
                    period = str(pd.to_datetime(period).date())
                except Exception:
                    pass
            ratio_row = [
                period or "",
                f"{current_ratio:.5f}" if current_ratio is not None else "",
                f"{quick_ratio:.5f}" if quick_ratio is not None else "",
                f"{debt_equity:.5f}" if debt_equity is not None else "",
                f"{gross_margin:.5f}" if gross_margin is not None else "",
                f"{net_margin:.5f}" if net_margin is not None else "",
                f"{roa:.5f}" if roa is not None else "",
                f"{roe:.5f}" if roe is not None else "",
            ]
            ratio_rows.append(ratio_row)
            latest_ratio_dict = {
                "period": period or "",
                "current_ratio": current_ratio,
                "quick_ratio": quick_ratio,
                "debt_equity": debt_equity,
                "gross_margin": gross_margin,
                "net_margin": net_margin,
                "roa": roa,
                "roe": roe,
            }
        except Exception:
            continue
    # Formatted string for latest period
    latest_str = ""
    if latest_ratio_dict:
        latest_str = f"\n**Key Financial Ratios (latest period: {latest_ratio_dict['period']}):**\n"
        if latest_ratio_dict["current_ratio"] is not None:
            latest_str += f"- Current Ratio: {latest_ratio_dict['current_ratio']:.5f}\n"
        if latest_ratio_dict["quick_ratio"] is not None:
            latest_str += f"- Quick Ratio: {latest_ratio_dict['quick_ratio']:.5f}\n"
        if latest_ratio_dict["debt_equity"] is not None:
            latest_str += f"- Debt/Equity: {latest_ratio_dict['debt_equity']:.5f}\n"
        if latest_ratio_dict["gross_margin"] is not None:
            latest_str += f"- Gross Margin: {latest_ratio_dict['gross_margin']:.5f}\n"
        if latest_ratio_dict["net_margin"] is not None:
            latest_str += f"- Net Margin: {latest_ratio_dict['net_margin']:.5f}\n"
        if latest_ratio_dict["roa"] is not None:
            latest_str += f"- ROA: {latest_ratio_dict['roa']:.5f}\n"
        if latest_ratio_dict["roe"] is not None:
            latest_str += f"- ROE: {latest_ratio_dict['roe']:.5f}\n"
    return ratio_header, ratio_rows, latest_str


def _get_llm_commentary_section(lines, context_info):
    """Generate LLM-driven qualitative commentary for the report, using context and prompt.

    Args:
        lines (list): List of report lines constructed so far.
        context_info (dict): Contextual information for the analysis.

    Returns:
        str: LLM-generated commentary string, or error message if unavailable.
    """
    try:
        from altman_zscore.api.openai_client import get_llm_qualitative_commentary
        prompt_path_new = os.path.abspath(
            os.path.join(os.path.dirname(__file__), "..", "prompts", "prompt_fin_analysis.md")
        )
        prompt_path_legacy = os.path.abspath(
            os.path.join(os.path.dirname(__file__), "prompts", "prompt_fin_analysis.md")
        )
        if os.path.exists(prompt_path_new):
            prompt_path = prompt_path_new
        elif os.path.exists(prompt_path_legacy):
            prompt_path = prompt_path_legacy
        else:
            raise FileNotFoundError(
                f"Could not find prompt_fin_analysis.md in either src/prompts/ or src/altman_zscore/prompts/. Checked: {prompt_path_new}, {prompt_path_legacy}"
            )
        with open(prompt_path, "r", encoding="utf-8") as f:
            llm_prompt = f.read()
        # --- Inject only the latest key financial ratios section at the very top (no weekly prices table) ---
        ratios_section = ""
        try:
            df = None
            if context_info and "_df" in context_info:
                df = context_info["_df"]
            elif hasattr(context_info, "get") and callable(context_info.get):
                df = context_info.get("_df")
            quarters = context_info["raw_quarters"] if context_info and "raw_quarters" in context_info else None
            if not quarters and df is not None and isinstance(df, pd.DataFrame):
                quarters = df.to_dict(orient="records")
            ticker = None
            if context_info and "Ticker" in context_info:
                tval = context_info["Ticker"]
                if isinstance(tval, str):
                    ticker = tval.upper()
                elif tval is not None:
                    ticker = str(tval)
            fin_raw = {}
            if ticker:
                fin_raw_path = os.path.join("output", ticker, "financials_raw.json")
                if os.path.exists(fin_raw_path):
                    with open(fin_raw_path, "r", encoding="utf-8") as f:
                        fin_raw = json.load(f)
            _, _, latest_str = get_key_financial_ratios(quarters or [], fin_raw)
            ratios_section = latest_str
        except Exception:
            pass
        # Place ratios_section at the very top, before any other context (including officers, company profile, etc.)
        context = "\n".join(lines)
        # Remove any weekly prices table from the context injection (if present)
        context = re.sub(r"- \*\*weekly_prices:\*\*.*?\[\d+ rows x \d+ columns\]\n", "", context, flags=re.DOTALL)
        if ratios_section:
            context = ratios_section.strip() + "\n\n" + context
        ticker = None
        if context_info and "Ticker" in context_info:
            tval = context_info["Ticker"]
            if isinstance(tval, str):
                ticker = tval
            elif tval is not None:
                ticker = str(tval)
        # llm_commentary = get_llm_qualitative_commentary(f"{context}\n\n---\n\n{llm_prompt}", ticker=ticker)
        llm_commentary = get_llm_qualitative_commentary(f"\n\n\n{llm_prompt}", ticker=ticker)
        return llm_commentary.strip() + "\n"
    except Exception as exc:
        return f"> [LLM commentary unavailable: {exc}]"


def _get_appendix_section(df, context_info=None, out_base=None):
    """Generate the appendix section with raw data, prices, ratios, provenance, quality, and metadata.

    Args:
        df (pd.DataFrame): DataFrame with Z-Score and financial data.
        context_info (dict, optional): Contextual information for the analysis.
        out_base (str, optional): Output base name for report files.

    Returns:
        str: Markdown-formatted appendix section.
    """
    appendix_md = []

    # --- Restore: Raw Financial Data Table ---
    quarters = None
    if context_info and "raw_quarters" in context_info:
        quarters = context_info["raw_quarters"]
    if isinstance(quarters, pd.DataFrame):
        quarters = quarters.to_dict(orient="records")
    # Now safe to check for emptiness
    if not quarters or not isinstance(quarters, list) or len(quarters) == 0:
        appendix_md.append("No raw financial data available for appendix.")
    else:
        fields = [
            "period_end", "current_assets", "current_liabilities", "retained_earnings", "ebit", "total_assets", "total_liabilities", "sales"
        ]
        present_fields = [f for f in fields if any(f in q for q in quarters)]
        header = [f.replace("_", " ").title() for f in present_fields]
        def fmt_millions(val):
            try:
                v = float(val)
                return f"{v/1_000_000:.1f}"
            except Exception:
                return str(val) if val is not None else ""
        def fmt_date(val):
            try:
                if not val:
                    return ""
                if isinstance(val, str):
                    return pd.to_datetime(val[:10]).strftime("%Y-%m-%d")
                elif hasattr(val, 'strftime'):
                    return val.strftime("%Y-%m-%d")
                else:
                    return str(val)
            except Exception:
                return str(val)
        rows = []
        for q in quarters:
            row = [fmt_date(q.get(f, "")) if f == "period_end" else fmt_millions(q.get(f, "")) for f in present_fields]
            rows.append(row)
        appendix_md.append("| " + " | ".join(header) + " |")
        appendix_md.append("|" + "|".join(["---"] * len(header)) + "|")
        for row in rows:
            appendix_md.append("| " + " | ".join(str(x) if x is not None else "" for x in row) + " |")

    # --- Restore: Weekly Prices Table ---
    weekly_prices = None
    if context_info and "weekly_prices" in context_info:
        weekly_prices = context_info["weekly_prices"]
    if not weekly_prices:
        weekly_prices = getattr(df, "weekly_prices", None)
    if weekly_prices is not None:
        appendix_md.append("\n**Appendix: Weekly Prices Used for Z-Score Analysis**\n")
        try:
            wp_df = weekly_prices
            # Handle both DataFrame and list-of-dict
            if isinstance(wp_df, pd.DataFrame):
                columns = list(wp_df.columns)
                if len(columns) > 12:
                    columns = columns[:12]
                header = [str(c).replace("_", " ").title() for c in columns]
                appendix_md.append("| " + " | ".join(header) + " |")
                appendix_md.append("|" + "|".join(["---"] * len(header)) + "|")
                def fmt_price(val):
                    try:
                        return f"{float(val):.3f}"
                    except Exception:
                        return str(val) if val is not None else ""
                for _, row in wp_df.iterrows():
                    formatted_row = []
                    for c in columns:
                        if c in ("avg_price", "min_price", "max_price"):
                            formatted_row.append(fmt_price(row[c]))
                        elif c == "week":
                            try:
                                v = row[c]
                                if isinstance(v, str):
                                    formatted_row.append(pd.to_datetime(v[:10]).strftime("%Y-%m-%d"))
                                elif hasattr(v, 'strftime'):
                                    formatted_row.append(v.strftime("%Y-%m-%d"))
                                else:
                                    formatted_row.append(str(v))
                            except Exception:
                                formatted_row.append(str(row[c]))
                        else:
                            formatted_row.append(str(row[c]) if row[c] is not None else "")
                    appendix_md.append("| " + " | ".join(formatted_row) + " |")
            elif isinstance(wp_df, list) and wp_df and isinstance(wp_df[0], dict):
                columns = list(wp_df[0].keys())
                if len(columns) > 12:
                    columns = columns[:12]
                header = [str(c).replace("_", " ").title() for c in columns]
                appendix_md.append("| " + " | ".join(header) + " |")
                appendix_md.append("|" + "|".join(["---"] * len(header)) + "|")
                def fmt_price(val):
                    try:
                        return f"{float(val):.3f}"
                    except Exception:
                        return str(val) if val is not None else ""
                for row in wp_df:
                    formatted_row = []
                    for c in columns:
                        if c in ("avg_price", "min_price", "max_price"):
                            formatted_row.append(fmt_price(row.get(c)))
                        elif c == "week":
                            try:
                                v = row.get(c)
                                if isinstance(v, str):
                                    formatted_row.append(pd.to_datetime(v[:10]).strftime("%Y-%m-%d"))
                                elif hasattr(v, 'strftime'):
                                    formatted_row.append(v.strftime("%Y-%m-%d"))
                                else:
                                    formatted_row.append(str(v))
                            except Exception:
                                formatted_row.append(str(row.get(c)))
                        else:
                            formatted_row.append(str(row.get(c)) if row.get(c) is not None else "")
                    appendix_md.append("| " + " | ".join(formatted_row) + " |")
            else:
                appendix_md.append("[Could not render weekly prices table: Unrecognized data format]")
        except Exception as e:
            appendix_md.append(f"[Could not render weekly prices table: {e}]")

    # 1. Key Financial Ratios Table (per period)
    appendix_md.append("\n**Appendix: Key Financial Ratios (per period)**\n")
    try:
        quarters = None
        if context_info and "raw_quarters" in context_info:
            quarters = context_info["raw_quarters"]
        if isinstance(quarters, pd.DataFrame):
            quarters = quarters.to_dict(orient="records")
        if not quarters and hasattr(df, "to_dict"):
            quarters = df.to_dict(orient="records")
        if isinstance(quarters, pd.DataFrame):
            quarters = quarters.to_dict(orient="records")
        if not quarters or not isinstance(quarters, list):
            quarters = []
        ticker = None
        if context_info and "Ticker" in context_info:
            ticker = context_info["Ticker"].upper()
        fin_raw = {}
        if ticker:
            fin_raw_path = os.path.join("output", ticker, "financials_raw.json")
            if os.path.exists(fin_raw_path):
                with open(fin_raw_path, "r", encoding="utf-8") as f:
                    fin_raw = json.load(f)
        ratio_header, ratio_rows, _ = get_key_financial_ratios(quarters, fin_raw)
        if ratio_rows:
            appendix_md.append("| " + " | ".join(ratio_header) + " |")
            appendix_md.append("|" + "|".join(["---"] * len(ratio_header)) + "|")
            for row in ratio_rows:
                appendix_md.append("| " + " | ".join(row) + " |")
        else:
            appendix_md.append("No ratio data available.")
    except Exception as e:
        appendix_md.append(f"[Could not compute ratios: {e}]")

    # 2. Data Provenance
    appendix_md.append("\n**Appendix: Data Provenance**\n")
    try:
        provenance_lines = []
        # Try to get fetch timestamps from DataFrame or context_info
        if hasattr(df, "provenance"):
            prov = getattr(df, "provenance")
            for k, v in prov.items():
                provenance_lines.append(f"- {k}: {v}")
        # Try to find output files for this ticker
        ticker = None
        if context_info and "Ticker" in context_info:
            ticker = context_info["Ticker"].upper()
        if ticker:
            out_dir = os.path.join("output", ticker)
            for fname in ["financials_quarterly.json", "weekly_prices.json", "company_info.json", "yf_info.json"]:
                fpath = os.path.join(out_dir, fname)
                if os.path.exists(fpath):
                    ts = datetime.fromtimestamp(os.path.getmtime(fpath)).strftime("%Y-%m-%d %H:%M:%S")
                    provenance_lines.append(f"- {fname}: last modified {ts}")
        if provenance_lines:
            appendix_md.extend(provenance_lines)
        else:
            appendix_md.append("No provenance data available.")
    except Exception as e:
        appendix_md.append(f"[Could not get provenance: {e}]")

    # 3. Data Quality/Completeness Summary
    appendix_md.append("\n**Appendix: Data Quality/Completeness Summary**\n")
    try:
        missing_summary = []
        if hasattr(df, "missing_fields"):
            missing_fields = getattr(df, "missing_fields")
            if isinstance(missing_fields, pd.DataFrame):
                missing_fields = list(missing_fields.columns) if not missing_fields.empty else []
            elif isinstance(missing_fields, dict):
                missing_fields = list(missing_fields.keys())
            elif isinstance(missing_fields, (list, set)):
                missing_fields = [str(x) for x in missing_fields]
            if missing_fields:
                missing_summary.append(
                    "> **Warning:** The following required fields were missing for one or more quarters: "
                    + ", ".join(sorted(missing_fields))
                )
        elif hasattr(df, "zscore_results"):
            zscore_results = getattr(df, "zscore_results")
            if zscore_results is not None:  # Handle both list and DataFrame cases
                missing = set()
                if isinstance(zscore_results, pd.DataFrame):
                    zscore_results = zscore_results.to_dict(orient="records")
                if isinstance(zscore_results, (list, tuple)):
                    for res in zscore_results:
                        if hasattr(res, "missing_fields"):
                            res_fields = getattr(res, "missing_fields")
                            if isinstance(res_fields, pd.DataFrame):
                                res_fields = list(res_fields.columns) if not res_fields.empty else []
                            elif isinstance(res_fields, dict):
                                res_fields = list(res_fields.keys())
                            elif isinstance(res_fields, (list, set)):
                                res_fields = [str(x) for x in res_fields]
                            if res_fields:
                                missing.update(res_fields)
                if missing:
                    missing_summary.append(
                        "> **Warning:** The following required fields were missing for one or more quarters: "
                        + ", ".join(sorted(missing))
                    )

        quarters = None
        if context_info and "raw_quarters" in context_info:
            quarters = context_info["raw_quarters"]
        if isinstance(quarters, pd.DataFrame):
            quarters = quarters.to_dict(orient="records")
        if not quarters and hasattr(df, "to_dict"):
            quarters = df.to_dict(orient="records")
        if isinstance(quarters, pd.DataFrame):
            quarters = quarters.to_dict(orient="records")
        if quarters and isinstance(quarters, list):
            for q in quarters:
                missing_fields = q.get("missing_fields", [])
                if isinstance(missing_fields, pd.DataFrame):
                    missing_fields = list(missing_fields.columns) if not missing_fields.empty else []
                elif isinstance(missing_fields, dict):
                    missing_fields = list(missing_fields.keys())
                elif isinstance(missing_fields, (list, set)):
                    missing_fields = [str(x) for x in missing_fields]
                if missing_fields:
                    period = q.get("period_end", "?")
                    missing_summary.append(f"- {period}: missing {', '.join(missing_fields)}")
        if missing_summary:
            appendix_md.extend(missing_summary)
        else:
            appendix_md.append("No missing/estimated fields detected.")
    except Exception as e:
        appendix_md.append(f"[Could not summarize data quality: {e}]")

    # 5. Company Metadata
    appendix_md.append("\n**Appendix: Company Metadata**\n")
    try:
        ticker = None
        if context_info and "Ticker" in context_info:
            ticker = context_info["Ticker"].upper()
        meta_lines = []
        meta = {}
        if ticker:
            out_dir = os.path.join("output", ticker)
            for fname in ["company_info.json", "yf_info.json"]:
                fpath = os.path.join(out_dir, fname)
                if os.path.exists(fpath):
                    with open(fpath, "r", encoding="utf-8") as f:
                        try:
                            data = json.load(f)
                            meta.update(data)
                        except Exception:
                            continue
        # Compose metadata table
        meta_fields = [
            ("Name", meta.get("name") or meta.get("shortName") or meta.get("longName")),
            ("Sector", meta.get("sector") or meta.get("sectorDisp")),
            ("Industry", meta.get("industry") or meta.get("industryDisp")),
            ("Country", meta.get("country")),
            ("Market Cap", f"{meta.get('marketCap'):,}" if meta.get("marketCap") else None),
            ("Employees", str(meta.get("fullTimeEmployees")) if meta.get("fullTimeEmployees") else None),
            ("Fiscal Year End", meta.get("fiscalYearEnd")),
            ("Exchange", meta.get("exchange") or meta.get("exchanges")),
            ("CIK", meta.get("cik")),
            ("SIC", meta.get("sic")),
            ("Website", meta.get("website")),
        ]
        appendix_md.append("| Field | Value |\n|---|---|")
        for k, v in meta_fields:
            if v:
                appendix_md.append(f"| {k} | {v} |")
        if not any(v for _, v in meta_fields):
            appendix_md.append("No metadata available.")
    except Exception as e:
        appendix_md.append(f"[Could not get company metadata: {e}]")

    return "\n".join(appendix_md)


def _standardize_report_data(df, context_info=None):
    """Standardize data format for report generation.

    Data is assumed to be validated by previous pipeline steps.

    Args:
        df (pd.DataFrame): DataFrame with Z-Score and financial data.
        context_info (dict, optional): Contextual information for the analysis.

    Returns:
        tuple: (processed_quarters, raw_quarters, missing_fields)
            processed_quarters (list): List of processed quarter dicts.
            raw_quarters (list): List of raw quarter dicts.
            missing_fields (list): Sorted list of missing field names.
    """
    processed_quarters = df.to_dict(orient="records") if isinstance(df, pd.DataFrame) else []
    raw_quarters = []
    missing_fields = set()
    
    # Get raw quarters from context if available
    if context_info and "raw_quarters" in context_info:
        raw_data = context_info["raw_quarters"]
        raw_quarters = raw_data.to_dict(orient="records") if isinstance(raw_data, pd.DataFrame) else raw_data if isinstance(raw_data, list) else []

    # Collect missing fields - already validated, just need to standardize format
    missing_fields_attr = getattr(df, "missing_fields", None)
    if missing_fields_attr is not None:
        if isinstance(missing_fields_attr, pd.DataFrame):
            missing_fields.update(missing_fields_attr.columns)
        elif isinstance(missing_fields_attr, dict):
            missing_fields.update(missing_fields_attr.keys())
        elif isinstance(missing_fields_attr, (list, set)):
            missing_fields.update(str(x) for x in missing_fields_attr)

    # Handle zscore_results missing fields if present
    zscore_results = getattr(df, "zscore_results", None)
    if zscore_results is not None:
        if isinstance(zscore_results, pd.DataFrame):
            results = zscore_results.to_dict(orient="records")
        else:
            results = zscore_results if isinstance(zscore_results, (list, tuple)) else []
        
        for res in results:
            res_missing = getattr(res, "missing_fields", None)
            if res_missing is not None:
                if isinstance(res_missing, pd.DataFrame):
                    missing_fields.update(res_missing.columns)
                elif isinstance(res_missing, dict):
                    missing_fields.update(res_missing.keys())
                elif isinstance(res_missing, (list, set)):
                    missing_fields.update(str(x) for x in res_missing)
    
    return processed_quarters, raw_quarters, sorted(missing_fields)


def report_zscore_full_report(df, model, out_base=None, print_to_console=True, context_info=None, model_obj=None, calibration=None):
    """Generate a full Altman Z-Score analysis report in Markdown format.

    Args:
        df (pd.DataFrame): DataFrame with Z-Score and financial data.
        model (str): Model identifier.
        out_base (str, optional): Output base name for report files.
        print_to_console (bool, optional): If True, do not print or log the full report to console/logs.
        context_info (dict, optional): Contextual information for the analysis.
        model_obj (object, optional): Model object (unused).
        calibration (object, optional): Calibration object (unused).

    Returns:
        str or None: Markdown-formatted report string, or None if report is empty.

    Notes:
        - Saves the report to disk if out_base is provided.
        - Embeds company logo and chart if available.
        - LLM commentary and appendices are included as appropriate.
    """
    # Ensure context_info exists
    if context_info is None:
        context_info = {}
    
    # Standardize data format
    processed_quarters, raw_quarters, missing_fields = _standardize_report_data(df, context_info)
    context_info["_standardized"] = {
        "processed_quarters": processed_quarters,
        "raw_quarters": raw_quarters,
        "missing_fields": missing_fields
    }
      # Build report sections
    lines = []

    # Insert company logo at the top if available or fetch if missing
    ticker = context_info.get("Ticker") if context_info else None
    logo_md = None
    if ticker:
        logo_dir = os.path.join("output", ticker)
        logo_path = os.path.join(logo_dir, f"{ticker}_logo.png")
        # If logo does not exist, try to fetch and save as {TICKER}_logo.png (200x200)
        if not os.path.exists(logo_path):
            try:
                client = FinnhubClient()
                # Ensure FinnhubClient saves the logo as {TICKER}_logo.png at 200x200
                client.get_company_profile(ticker, logo_size=(200, 200), logo_path=logo_path)
            except Exception as e:
                logging.warning(f"Could not fetch company logo for {ticker}: {e}")
        # Now ensure the logo is 200x200
        if os.path.exists(logo_path):
            try:
                with Image.open(logo_path) as img:
                    if img.size != (200, 200):
                        img = img.convert('RGBA')
                        img = img.resize((200, 200), Image.Resampling.LANCZOS)
                        img.save(logo_path, format='PNG', optimize=True)
                logo_md = f'![Company Logo]({ticker}_logo.png)\n'
            except Exception as e:
                logging.warning(f"Could not process company logo for report: {e}")
    if logo_md:
        lines.append(logo_md)

    # Core report content
    lines.extend(_get_report_intro_and_title(context_info))
    lines.append(_get_script_version())
    # lines.extend(_get_context_section(context_info))
    
    # Model info and formula
    model_label, model_name, override_lines = _get_model_label_and_overrides(df, model, context_info)
    lines.extend(override_lines)
    formula_lines, threshold_lines, x_cols = _get_formula_and_threshold_section(model_name)
    lines.extend(formula_lines)
    lines.extend(threshold_lines)
    
    # Missing fields warning
    if missing_fields:
        lines.append(
            "> **Warning:** The following required fields were missing for one or more quarters: "
            + ", ".join(sorted(missing_fields))
            + ". Z-Score components for these fields are omitted or estimated. Interpret results with caution."
        )
        lines.append("")
    
    # Analysis results
    lines.append("\n\n## Graphical View of the Z-Score Analysis\n")
    if chart_md := _get_chart_md(context_info, out_base):
        lines.append(chart_md)
    lines.append("\n## Z-Score Component Table (by Quarter)")
    lines.append(_get_zscore_component_table(df, x_cols))
    lines.append("\n")
    # Generate LLM commentary with the report content constructed so far
    commentary = _get_llm_commentary_section(lines, context_info)
    lines.append(commentary)
    # Do NOT generate appendices or market sentiment tables here; LLM will generate them from injected data
    # lines.append("\n\n## Appendices\n")
    # lines.extend(_get_appendix_section(df, context_info=context_info, out_base=out_base).split('\n'))
    # Inject Market Sentiment Analysis (Analyst Recommendations) -- now handled by LLM
    # ...existing code...
    # Generate final report
    report_md = "\n".join(lines)
    if not report_md.strip():
        logging.warning("[WARNING] report_md is empty. No report will be saved.")
        return None
    
    # Save report if path provided
    if out_base and (ticker := str(context_info.get("Ticker", "")).upper()):
        if not out_base.startswith(f"{ticker}/") and not out_base.startswith(f"{ticker}\\"):
            out_base = os.path.join(ticker, out_base)
        
        out_path = get_output_dir(relative_path=f"{out_base}_zscore_full_report.md")
        os.makedirs(os.path.dirname(out_path), exist_ok=True)
        
        with open(out_path, "w", encoding="utf-8") as f:
            f.write(report_md)
        logging.info(f"Full Z-Score report saved to {out_path}")
    if print_to_console:
        # Do not print or log the full report to console or logs
        pass
    return report_md


