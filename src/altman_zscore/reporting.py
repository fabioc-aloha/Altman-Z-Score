"""
Z-Score Text Reporting Utilities

This module provides functions to generate and save Altman Z-Score text reports and tables.
"""

import tabulate

from altman_zscore.utils.colors import Colors
from altman_zscore.utils.paths import get_output_dir
from altman_zscore.zscore_models import CompanyStage, ModelCoefficients, ModelThresholds, TechCalibration


def print_info(msg):
    """Print an info message with blue color if supported"""
    try:
        print(f"{Colors.BLUE}[INFO]{Colors.ENDC} {msg}")
    except Exception:
        print(f"[INFO] {msg}")


def report_zscore_full_report(
    df,
    model,
    out_base=None,
    print_to_console=True,
    context_info=None,
    model_obj=None,
    calibration=None,
):
    """
    Generate and save a full Altman Z-Score analysis report in Markdown format.
    Args:
        df: DataFrame with Z-Score results and mappings
        model: Z-Score model name
        out_base: Output file base name (no extension)
        print_to_console: If True, print the report to stdout
        context_info: Optional dict with company/ticker/industry context
    """
    # --- Introduction and Source Attribution ---
    intro_lines = [
        "---",
        "## Introduction",
        "This report provides a comprehensive, theory-informed financial health analysis of the selected company using the Altman Z-Score framework. It integrates quantitative diagnostics, turnaround management theory, and stakeholder recommendations, with all findings and recommendations grounded in referenced academic and industry sources. The analysis is generated by an expert LLM-driven pipeline, ensuring transparency, reproducibility, and robust source attribution.",
        "",
        "**Author:** Fabio Correa",
        "",
        "**Source Attribution:** This report and analysis pipeline are generated using the open-source Altman Z-Score Analysis project, available at [https://github.com/fabioc-aloha/Altman-Z-Score](https://github.com/fabioc-aloha/Altman-Z-Score).",
        "",
        "**License:** This software is distributed under the Attribution Non-Commercial License (MIT-based). See the LICENSE file for details.",
        "",
        "Disclaimer: The developer disclaims any responsibility for the accuracy, completeness, or consequences of the analysis and information provided by this software. All results are for informational purposes only and should not be relied upon for financial, investment, or legal decisions.",
        "---",
        "",
    ]
    company_name = None
    try:
        import yfinance as yf

        yf_ticker = yf.Ticker(context_info["Ticker"]) if context_info and "Ticker" in context_info else None
        if yf_ticker:
            info = yf_ticker.info
            company_name = info.get("shortName") or info.get("longName")
    except KeyError:
        company_name = None
    if not company_name and context_info and "Ticker" in context_info:
        company_name = context_info["Ticker"].upper()
    if company_name and context_info and "Ticker" in context_info:
        title = f"# Altman Z-Score Analysis Report: {company_name} ({context_info['Ticker'].upper()})"
    else:
        title = "# Altman Z-Score Analysis Report"
    # Place title at the very top, then intro_lines, then the rest
    lines = [title, ""] + intro_lines
    # --- Script Version Section ---
    try:
        from main import __version__ as pipeline_version
    except ImportError:
        pipeline_version = "unknown"
    lines.append(f"**Script Version:** v{pipeline_version}")
    lines.append("")
    lines.append("## Analysis Context and Z-Score Model Selection Criteria\n")
    if context_info:
        industry_val = context_info.get("Industry")
        sic_val = context_info.get("SIC Code")
        if industry_val and sic_val and industry_val != "Unknown":
            lines.append(f"- **Industry:** {industry_val} (SIC {sic_val})")
        else:
            lines.append(f"- **Industry:** {industry_val or sic_val}")
        for k, v in context_info.items():
            if k in ("Industry", "SIC Code"):
                continue
            lines.append(f"- **{k}:** {v}")
        lines.append("")
    # --- Model/Threshold Overrides and Assumptions Section ---
    MODEL_LABELS = {
        "original": "Original Z-Score (Public Manufacturing, 1968)",
        "private": "Z′-Score (Private Manufacturing, 1983)",
        "private_mfg": "Z′-Score (Private Manufacturing, 1983)",
        "private_service": "Zʺ-Score (Private Non-Manufacturing, Book Equity, 1995)",
        "service": "Zʺ-Score (Public Non-Manufacturing, 1995)",
        "emerging": "EM-Score (Emerging Markets, mid-1990s)",
    }
    override_context = None
    if hasattr(df, "zscore_results") and df.zscore_results:
        override_context = getattr(df.zscore_results[0], "override_context", None)
        if override_context:
            lines.append("### Model/Threshold Overrides and Assumptions\n")
            for k, v in override_context.items():
                lines.append(f"- **{k}:** {v}")
            lines.append("")
    elif "override_context" in df.columns:
        oc = df["override_context"].iloc[0]
        if oc:
            override_context = oc
            lines.append("### Model/Threshold Overrides and Assumptions\n")
            for k, v in oc.items():
                lines.append(f"- **{k}:** {v}")
            lines.append("")
    model_name = None
    if hasattr(df, 'zscore_results') and df.zscore_results and hasattr(df.zscore_results[0], 'model'):
        model_name = df.zscore_results[0].model
    elif 'model' in df.columns:
        model_name = df['model'].iloc[0]
    else:
        model_name = str(model).lower()
    # Defensive fallback
    if not model_name:
        model_name = 'original'
    model_label = MODEL_LABELS.get(str(model_name).lower(), str(model_name))
    # Insert model label into context section
    if context_info is not None:
        for idx, line in enumerate(lines):
            if line.strip().startswith('- **Model:**'):
                lines[idx] = f'- **Model:** {model_label} ({model_name})'
                break
    # --- Dynamically build formula and threshold display ---
    from altman_zscore.computation.constants import MODEL_COEFFICIENTS, Z_SCORE_THRESHOLDS
    formula_lines = []
    threshold_lines = []
    x_labels = []
    x_cols = []  # Ensure x_cols is always defined
    # Use the model name from the first row of the DataFrame if available
    model_name = None
    if hasattr(df, 'zscore_results') and df.zscore_results and hasattr(df.zscore_results[0], 'model'):
        model_name = df.zscore_results[0].model
    elif 'model' in df.columns:
        model_name = df['model'].iloc[0]
    else:
        model_name = str(model).lower()
    # Defensive fallback
    if not model_name:
        model_name = 'original'
    coeffs = MODEL_COEFFICIENTS.get(model_name, MODEL_COEFFICIENTS['original'])
    thresholds = Z_SCORE_THRESHOLDS.get(model_name, Z_SCORE_THRESHOLDS['original'])
    # Build formula string
    coeff_map = [
        ("X1", coeffs.get("A", 0), "(Current Assets - Current Liabilities) / Total Assets"),
        ("X2", coeffs.get("B", 0), "Retained Earnings / Total Assets"),
        ("X3", coeffs.get("C", 0), "EBIT / Total Assets"),
        ("X4", coeffs.get("D", 0), "Equity / Total Liabilities"),
        ("X5", coeffs.get("E", 0), "Sales / Total Assets"),
    ]
    terms = []
    for x, coeff, desc in coeff_map:
        if coeff != 0:
            terms.append(f"{coeff}*{x}")
            x_labels.append((x, desc))
            x_cols.append(x)
    formula_str = "Z = " + " + ".join(terms)
    formula_lines.append(f"## Z-Score Formula Used\n")
    formula_lines.append(formula_str)
    for x, desc in x_labels:
        formula_lines.append(f"- {x} = {desc}")
    formula_lines.append("")
    threshold_lines.append("**Thresholds:**")
    threshold_lines.append(f"- Safe Zone: > {thresholds['safe']}")
    threshold_lines.append(f"- Grey Zone: > {thresholds['distress']} and <= {thresholds['safe']}")
    threshold_lines.append(f"- Distress Zone: <= {thresholds['distress']}")
    threshold_lines.append("")
    # Insert formula and thresholds into report
    lines.extend(formula_lines)
    lines.extend(threshold_lines)
    # --- Warning Section for Missing Fields and Reliability Impact ---
    if hasattr(df, "missing_fields") and df.missing_fields:
        lines.append(
            "> **Warning:** The following required fields were missing for one or more quarters: "
            + ", ".join(sorted(set(df.missing_fields)))
            + ". Z-Score components for these fields are omitted or estimated. Interpret results with caution."
        )
        lines.append("")
    elif hasattr(df, "zscore_results") and df.zscore_results:
        # Check for missing fields in zscore_results if present
        missing = set()
        for res in df.zscore_results:
            if hasattr(res, "missing_fields") and res.missing_fields:
                missing.update(res.missing_fields)
        if missing:
            lines.append(
                "> **Warning:** The following required fields were missing for one or more quarters: "
                + ", ".join(sorted(missing))
                + ". Z-Score components for these fields are omitted or estimated. Interpret results with caution."
            )
            lines.append("")

    def format_number_millions(val):
        try:
            if val is None or val == "":
                return ""
            val = float(val)
            val_m = val / 1_000_000
            return f"{val_m:,.1f}"
        except ValueError:
            return str(val)

    mapping_rows = []
    mapping_header = ["Quarter", "Canonical Field", "Mapped Raw Field", "Value (USD millions)"]
    for idx, row in enumerate(df.iterrows()):
        _, row = row
        q = row.get("quarter_end")
        q_str = str(q)
        try:
            import pandas as pd

            dt = pd.to_datetime(q)
            q_str = f"{dt.year} Q{((dt.month-1)//3)+1}"
        except (ValueError, TypeError):
            pass
        field_mapping = row.get("field_mapping")
        if isinstance(field_mapping, str):
            try:
                import json

                field_mapping = json.loads(field_mapping)
            except Exception:
                field_mapping = {}
        if not isinstance(field_mapping, dict):
            field_mapping = {}
        for canon, mapping in field_mapping.items():
            mapped_raw = mapping.get("mapped_raw_field")
            val = mapping.get("value")
            mapping_rows.append(
                [
                    q_str,
                    canon,
                    mapped_raw if mapped_raw is not None else "",
                    format_number_millions(val),
                ]
            )
        if idx < len(df) - 1:
            mapping_rows.append(["---", "---", "---", "---"])
    mapping_table_str = tabulate.tabulate(mapping_rows, headers=mapping_header, tablefmt="github")
    # Do NOT append the Raw Data Field Mapping Table here
    rows = []
    for _, row in df.iterrows():
        q = row.get("quarter_end")
        q_str = str(q)
        try:
            import pandas as pd

            dt = pd.to_datetime(q)
            q_str = f"{dt.year} Q{((dt.month-1)//3)+1}"
        except (ValueError, TypeError):
            pass
        z = row.get("zscore")
        comps = row.get("components")
        diag = row.get("diagnostic")
        if isinstance(comps, str):
            try:
                import json

                comps = json.loads(comps)
            except Exception:
                comps = {}
        if not isinstance(comps, dict):
            comps = {}
        row_vals = [q_str]
        for x in x_cols:
            val = comps.get(x)
            row_vals.append(f"{val:.3f}" if val is not None else "")
        row_vals.append(f"{z:.3f}" if z is not None else "")
        row_vals.append(diag or "")
        rows.append(row_vals)
    header = ["Quarter"] + x_cols + ["Z-Score", "Diagnostic"]
    # Add consistency warnings to the Z-Score Component Table if present
    if "consistency_warning" in df.columns:
        header.append("Consistency Warning")
        for i, (_, row) in enumerate(df.iterrows()):
            warning = row.get("consistency_warning")
            rows[i].append(warning if warning else "")
        table_str = tabulate.tabulate(rows, headers=header, tablefmt="github")
    else:
        table_str = tabulate.tabulate(rows, headers=header, tablefmt="github")
    # Do NOT append the Z-Score Component Table here
    import os  # Ensure os is imported before chart embedding logic

    lines.append("\n\n---\n\n# Graphical View of the Z-Score Analysis\n")
    # --- Chart Section (standalone section before LLM commentary) ---
    ticker = context_info.get("Ticker") if context_info else None
    out_path = None
    if out_base:
        out_path = get_output_dir(relative_path=f"{out_base}_zscore_full_report.md")
    chart_md = None
    if ticker and out_path:
        github_chart_path = f"zscore_{ticker}_trend.png"
        local_chart_path = os.path.abspath(os.path.join("output", ticker, f"zscore_{ticker}_trend.png"))
        out_dir = os.path.abspath(os.path.dirname(out_path))
        chart_dir = os.path.dirname(local_chart_path)
        if out_dir == chart_dir:
            chart_md = f"\n![Z-Score and Price Trend Chart]({github_chart_path})\n"
        else:
            rel_chart_path = os.path.relpath(local_chart_path, out_dir).replace("\\", "/")
            chart_md = f"\n![Z-Score and Price Trend Chart]({rel_chart_path})\n"
        chart_md += "\n"  # Add a new line before the caption
        if os.path.exists(local_chart_path):
            chart_md += f"*Figure: Z-Score and stock price trend for {ticker.upper()} (see output folder for full-resolution image)*\n"
        else:
            chart_md += f"*Figure: Z-Score and stock price trend for {ticker.upper()} (image not available yet; will be generated after analysis)*\n"
    if chart_md:
        lines.append(chart_md)
    # --- Z-Score Component Table (by Quarter) after the chart ---
    lines.append("\n## Z-Score Component Table (by Quarter)")
    lines.append(table_str)
    # --- LLM Commentary Section ---
    try:
        from altman_zscore.api.openai_client import get_llm_qualitative_commentary

        prompt_path_new = os.path.abspath(
            os.path.join(os.path.dirname(__file__), "..", "prompts", "prompt_fin_analysis.md")
        )
        prompt_path_legacy = os.path.abspath(
            os.path.join(os.path.dirname(__file__), "prompts", "prompt_fin_analysis.md")
        )
        if os.path.exists(prompt_path_new):
            prompt_path = prompt_path_new
        elif os.path.exists(prompt_path_legacy):
            prompt_path = prompt_path_legacy
        else:
            raise FileNotFoundError(
                f"Could not find prompt_fin_analysis.md in either src/prompts/ or src/altman_zscore/prompts/. Checked: {prompt_path_new}, {prompt_path_legacy}"
            )
        with open(prompt_path, "r", encoding="utf-8") as f:
            llm_prompt = f.read()
        # Prepend intro_lines to lines for LLM context and final report
        context = "\n".join(lines)  # Do NOT prepend intro_lines again
        full_prompt = f"{llm_prompt}\n\n---\n\n{context}"
        llm_commentary = get_llm_qualitative_commentary(full_prompt)
        lines.append(llm_commentary.strip() + "\n")
    except Exception as exc:
        lines.append(f"> [LLM commentary unavailable: {exc}]")
    # --- Appendix: Input Data Tables ---
    lines.append("\n\n---\n\n# Appendix\n")
    lines.append("## Raw Data Field Mapping Table (by Quarter)")
    lines.append(mapping_table_str)
    lines.append("")
    lines.append("All values are shown in millions of USD as reported by the data source.")
    lines.append("")
    import os  # Ensure os is imported for chart embedding logic

    if out_base:
        out_path = get_output_dir(relative_path=f"{out_base}_zscore_full_report.md")
    # Removed hardcoded References and Data Sources section. The LLM now generates this section per prompt instructions.
    # Prepend intro_lines to lines for the final report output
    report = "\n".join(lines)  # Do NOT prepend intro_lines again
    if out_path:
        try:
            with open(out_path, "w", encoding="utf-8") as f:
                f.write(report + "\n")
            print_info(f"[SUCCESS] Full report saved to {out_path}")
        except (OSError, IOError) as exc:
            print_info(f"[ERROR] Could not save report to {out_path}: {exc}")
    return report


