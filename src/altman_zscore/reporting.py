"""
Z-Score Text Reporting Utilities

This module provides functions to generate and save Altman Z-Score text reports and tables.
"""
import os
import tabulate
from altman_zscore.utils.paths import get_output_dir
from altman_zscore.utils.colors import Colors

def print_info(msg):
    """Print an info message with blue color if supported"""
    try:
        print(f"{Colors.BLUE}[INFO]{Colors.ENDC} {msg}")
    except:
        print(f"[INFO] {msg}")

def report_zscore_full_report(df, model, out_base=None, print_to_console=True, context_info=None, generate_docx=True):
    """
    Generate and save a full Altman Z-Score analysis report in Markdown format, and optionally convert it to DOCX (Word).
    Args:
        df: DataFrame with Z-Score results and mappings
        model: Z-Score model name
        out_base: Output file base name (no extension)
        print_to_console: If True, print the report to stdout
        context_info: Optional dict with company/ticker/industry context
        generate_docx: If True (default), also generate a DOCX version of the report
    """
    # --- Introduction and Source Attribution ---
    intro_lines = [
        "---",
        "## Introduction",
        "This report provides a comprehensive, theory-informed financial health analysis of the selected company using the Altman Z-Score framework. It integrates quantitative diagnostics, turnaround management theory, and stakeholder recommendations, with all findings and recommendations grounded in referenced academic and industry sources. The analysis is generated by an expert LLM-driven pipeline, ensuring transparency, reproducibility, and robust source attribution.",
        "",
        "**Author:** Fabio Correa",
        "",
        "**Source Attribution:** This report and analysis pipeline are generated using the open-source Altman Z-Score Analysis project, available at [https://github.com/fabioc-aloha/Altman-Z-Score](https://github.com/fabioc-aloha/Altman-Z-Score).",
        "",
        "**License:** This software is distributed under the Attribution Non-Commercial License (MIT-based). See the LICENSE file for details.",
        "",
        "<span style='font-size:smaller'><em>Disclaimer: The developer disclaims any responsibility for the accuracy, completeness, or consequences of the analysis and information provided by this software. All results are for informational purposes only and should not be relied upon for financial, investment, or legal decisions.</em></span>",
        "---",
        ""
    ]
    company_name = None
    try:
        import yfinance as yf
        yf_ticker = yf.Ticker(context_info["Ticker"]) if context_info and "Ticker" in context_info else None
        if yf_ticker:
            info = yf_ticker.info
            company_name = info.get('shortName') or info.get('longName')
    except Exception:
        company_name = None
    if not company_name and context_info and "Ticker" in context_info:
        company_name = context_info["Ticker"].upper()
    if company_name and context_info and "Ticker" in context_info:
        title = f"# Altman Z-Score Analysis Report: {company_name} ({context_info['Ticker'].upper()})"
    else:
        title = "# Altman Z-Score Analysis Report"
    # Place title at the very top, then intro_lines, then the rest
    lines = [title, ""] + intro_lines
    lines.append("## Analysis Context and Z-Score Model Selection Criteria\n")
    if context_info:
        industry_val = context_info.get("Industry")
        sic_val = context_info.get("SIC Code")
        if industry_val and sic_val and industry_val != "Unknown":
            lines.append(f"- **Industry:** {industry_val} (SIC {sic_val})")
        else:
            lines.append(f"- **Industry:** {industry_val or sic_val}")
        for k, v in context_info.items():
            if k in ("Industry", "SIC Code"):
                continue
            lines.append(f"- **{k}:** {v}")
        lines.append("")
    # --- Model/Threshold Overrides and Assumptions Section ---
    # If the DataFrame contains a ZScoreResult with override_context, log it
    if hasattr(df, 'zscore_results') and df.zscore_results:
        override_context = getattr(df.zscore_results[0], 'override_context', None)
        if override_context:
            lines.append("### Model/Threshold Overrides and Assumptions\n")
            for k, v in override_context.items():
                lines.append(f"- **{k}:** {v}")
            lines.append("")
    elif 'override_context' in df.columns:
        # If override_context is a column (e.g., from DataFrame of results)
        oc = df['override_context'].iloc[0]
        if oc:
            lines.append("### Model/Threshold Overrides and Assumptions\n")
            for k, v in oc.items():
                lines.append(f"- **{k}:** {v}")
            lines.append("")
    model = str(model).lower()
    lines.append("")
    if model == "original":
        lines.append("## Altman Z-Score (Original) Formula\n")
        lines.append("Z = 1.2*X1 + 1.4*X2 + 3.3*X3 + 0.6*X4 + 1.0*X5")
        lines.append("- X1 = (Current Assets - Current Liabilities) / Total Assets")
        lines.append("- X2 = Retained Earnings / Total Assets")
        lines.append("- X3 = EBIT / Total Assets")
        lines.append("- X4 = Market Value of Equity / Total Liabilities")
        lines.append("- X5 = Sales / Total Assets\n")
        x_cols = ["X1", "X2", "X3", "X4", "X5"]
    elif model == "private":
        lines.append("## Altman Z-Score (Private) Formula\n")
        lines.append("Z' = 0.717*X1 + 0.847*X2 + 3.107*X3 + 0.420*X4 + 0.998*X5")
        lines.append("- X1 = (Current Assets - Current Liabilities) / Total Assets")
        lines.append("- X2 = Retained Earnings / Total Assets")
        lines.append("- X3 = EBIT / Total Assets")
        lines.append("- X4 = Book Value of Equity / Total Liabilities")
        lines.append("- X5 = Sales / Total Assets\n")
        x_cols = ["X1", "X2", "X3", "X4", "X5"]
    else:
        lines.append(f"## Altman Z-Score ({model.title()}) Formula\n")
        lines.append("Z = 6.56*X1 + 3.26*X2 + 6.72*X3 + 1.05*X4")
        lines.append("- X1 = (Current Assets - Current Liabilities) / Total Assets")
        lines.append("- X2 = Retained Earnings / Total Assets")
        lines.append("- X3 = EBIT / Total Assets")
        lines.append("- X4 = Market Value of Equity / Total Liabilities\n")
        x_cols = ["X1", "X2", "X3", "X4"]
    lines.append("")
    # --- Warning Section for Missing Fields and Reliability Impact ---
    if hasattr(df, 'missing_fields') and df.missing_fields:
        lines.append('> **Warning:** The following required fields were missing for one or more quarters: ' + ', '.join(sorted(set(df.missing_fields))) + '. Z-Score components for these fields are omitted or estimated. Interpret results with caution.')
        lines.append('')
    elif hasattr(df, 'zscore_results') and df.zscore_results:
        # Check for missing fields in zscore_results if present
        missing = set()
        for res in df.zscore_results:
            if hasattr(res, 'missing_fields') and res.missing_fields:
                missing.update(res.missing_fields)
        if missing:
            lines.append('> **Warning:** The following required fields were missing for one or more quarters: ' + ', '.join(sorted(missing)) + '. Z-Score components for these fields are omitted or estimated. Interpret results with caution.')
            lines.append('')
    def format_number_millions(val):
        try:
            if val is None or val == "":
                return ""
            val = float(val)
            val_m = val / 1_000_000
            return f"{val_m:,.1f}"
        except Exception:
            return str(val)
    mapping_rows = []
    mapping_header = ["Quarter", "Canonical Field", "Mapped Raw Field", "Value (USD millions)"]
    last_quarter = None
    for idx, row in enumerate(df.iterrows()):
        _, row = row
        q = row.get("quarter_end")
        q_str = str(q)
        try:
            import pandas as pd
            dt = pd.to_datetime(q)
            q_str = f"{dt.year} Q{((dt.month-1)//3)+1}"
        except Exception:
            pass
        field_mapping = row.get("field_mapping")
        if isinstance(field_mapping, str):
            try:
                import json
                field_mapping = json.loads(field_mapping)
            except Exception:
                field_mapping = {}
        if not isinstance(field_mapping, dict):
            field_mapping = {}
        for canon, mapping in field_mapping.items():
            mapped_raw = mapping.get("mapped_raw_field")
            val = mapping.get("value")
            mapping_rows.append([
                q_str,
                canon,
                mapped_raw if mapped_raw is not None else "",
                format_number_millions(val)
            ])
        if idx < len(df) - 1:
            mapping_rows.append(["---", "---", "---", "---"])
    mapping_table_str = tabulate.tabulate(mapping_rows, headers=mapping_header, tablefmt="github")
    lines.append("## Raw Data Field Mapping Table (by Quarter)")
    lines.append(mapping_table_str)
    lines.append("")
    lines.append("All values are shown in millions of USD as reported by the data source.")
    lines.append("")
    rows = []
    for _, row in df.iterrows():
        q = row.get("quarter_end")
        q_str = str(q)
        try:
            import pandas as pd
            dt = pd.to_datetime(q)
            q_str = f"{dt.year} Q{((dt.month-1)//3)+1}"
        except Exception:
            pass
        z = row.get("zscore")
        comps = row.get("components")
        diag = row.get("diagnostic")
        if isinstance(comps, str):
            try:
                import json
                comps = json.loads(comps)
            except Exception:
                comps = {}
        if not isinstance(comps, dict):
            comps = {}
        row_vals = [q_str]
        for x in x_cols:
            val = comps.get(x)
            row_vals.append(f"{val:.3f}" if val is not None else "")
        row_vals.append(f"{z:.3f}" if z is not None else "")
        row_vals.append(diag or "")
        rows.append(row_vals)
    header = ["Quarter"] + x_cols + ["Z-Score", "Diagnostic"]
    table_str = tabulate.tabulate(rows, headers=header, tablefmt="github")
    lines.append("\n\n## Z-Score Component Table (by Quarter)")
    lines.append(table_str)
    import os  # Ensure os is imported before chart embedding logic
    lines.append("\n\n---\n\n# Graphical View of the Z-Score Analysis\n")
    # --- Chart Section (standalone section before LLM commentary) ---
    ticker = context_info.get('Ticker') if context_info else None
    out_path = None
    if out_base:
        out_path = get_output_dir(relative_path=f"{out_base}_zscore_full_report.md")
    chart_md = None
    if ticker and out_path:
        # Try GitHub-friendly relative path first (assumes report and image are in the same output/<TICKER>/ folder)
        github_chart_path = f"zscore_{ticker}_trend.png"
        local_chart_path = os.path.join('output', ticker, f'zscore_{ticker}_trend.png')
        if os.path.exists(local_chart_path):
            # Use GitHub-friendly path if the report and image are in the same folder
            if os.path.dirname(out_path) == os.path.dirname(local_chart_path):
                chart_md = f"\n![Z-Score and Price Trend Chart]({github_chart_path})\n"
            else:
                rel_chart_path = os.path.relpath(local_chart_path, os.path.dirname(out_path)).replace('\\', '/')
                chart_md = f"\n![Z-Score and Price Trend Chart]({rel_chart_path})\n"
            chart_md += "\n"  # Add a new line before the caption
            chart_md += f"*Figure: Z-Score and stock price trend for {ticker.upper()} (see output folder for full-resolution image)*\n"
    if chart_md:
        lines.append(chart_md)
    # --- LLM Commentary Section ---
    try:
        from altman_zscore.api.openai_client import get_llm_qualitative_commentary
        prompt_path_new = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", "prompts", "prompt_fin_analysis.md"))
        prompt_path_legacy = os.path.abspath(os.path.join(os.path.dirname(__file__), "prompts", "prompt_fin_analysis.md"))
        if os.path.exists(prompt_path_new):
            prompt_path = prompt_path_new
        elif os.path.exists(prompt_path_legacy):
            prompt_path = prompt_path_legacy
        else:
            raise FileNotFoundError(f"Could not find prompt_fin_analysis.md in either src/prompts/ or src/altman_zscore/prompts/. Checked: {prompt_path_new}, {prompt_path_legacy}")
        with open(prompt_path, "r", encoding="utf-8") as f:
            llm_prompt = f.read()
        # Prepend intro_lines to lines for LLM context and final report
        context = "\n".join(lines)  # Do NOT prepend intro_lines again
        full_prompt = f"{llm_prompt}\n\n---\n\n{context}"
        llm_commentary = get_llm_qualitative_commentary(full_prompt)
        lines.append(llm_commentary.strip() + "\n")
    except Exception as e:
        lines.append("> [LLM commentary unavailable: {}]".format(e))
    import os  # Ensure os is imported for chart embedding logic
    docx_path = None
    if out_base:
        out_path = get_output_dir(relative_path=f"{out_base}_zscore_full_report.md")
    # Removed hardcoded References and Data Sources section. The LLM now generates this section per prompt instructions.
    # Prepend intro_lines to lines for the final report output
    report = "\n".join(lines)  # Do NOT prepend intro_lines again
    if out_path:
        try:
            with open(out_path, "w", encoding="utf-8") as f:
                f.write(report + "\n")
            print_info(f"[SUCCESS] Full report saved to {out_path}")
            # DOCX conversion removed
        except Exception as e:
            print_info(f"[ERROR] Could not save report to {out_path}: {e}")
    return report

# (md to docx conversion moved to md_to_docx.py for modularity)
