"""
Z-Score Text Reporting Utilities

This module provides functions to generate and save Altman Z-Score text reports and tables.
"""

import tabulate

from altman_zscore.utils.colors import Colors
from altman_zscore.utils.paths import get_output_dir
from altman_zscore.enums import CompanyStage
from altman_zscore.model_thresholds import ModelCoefficients, ModelThresholds, TechCalibration


def print_info(msg):
    """
    Print an info message with blue color if supported.

    Args:
        msg (str): The message to print.
    """
    try:
        print(f"{Colors.BLUE}[INFO]{Colors.ENDC} {msg}")
    except Exception:
        print(f"[INFO] {msg}")


def _get_report_intro_and_title(context_info):
    """Build the report title and introduction section."""
    intro_lines = [
        "---",
        "## Introduction",
        "This report provides a comprehensive, theory-informed financial health analysis of the selected company using the Altman Z-Score framework. It integrates quantitative diagnostics, turnaround management theory, and stakeholder recommendations, with all findings and recommendations grounded in referenced academic and industry sources. The analysis is generated by an expert LLM-driven pipeline, ensuring transparency, reproducibility, and robust source attribution.",
        "",
        "**Author:** Fabio Correa",
        "",
        "**Source Attribution:** This report and analysis pipeline are generated using the open-source Altman Z-Score Analysis project, available at [https://github.com/fabioc-aloha/Altman-Z-Score](https://github.com/fabioc-aloha/Altman-Z-Score).",
        "",
        "**License:** This software is distributed under the Attribution Non-Commercial License (MIT-based). See the LICENSE file for details.",
        "",
        "Disclaimer: The developer disclaims any responsibility for the accuracy, completeness, or consequences of the analysis and information provided by this software. All results are for informational purposes only and should not be relied upon for financial, investment, or legal decisions.",
        "---",
        "",
    ]
    company_name = None
    try:
        import yfinance as yf
        yf_ticker = yf.Ticker(context_info["Ticker"]) if context_info and "Ticker" in context_info else None
        if yf_ticker:
            info = yf_ticker.info
            company_name = info.get("shortName") or info.get("longName")
    except Exception:
        company_name = None
    if not company_name and context_info and "Ticker" in context_info:
        company_name = context_info["Ticker"].upper()
    if company_name and context_info and "Ticker" in context_info:
        title = f"# Altman Z-Score Analysis Report: {company_name} ({context_info['Ticker'].upper()})"
    else:
        title = "# Altman Z-Score Analysis Report"
    return [title, ""] + intro_lines


def _get_script_version():
    try:
        from main import __version__ as pipeline_version
    except ImportError:
        pipeline_version = "unknown"
    return f"**Script Version:** v{pipeline_version}"


def _get_context_section(context_info):
    lines = ["## Analysis Context and Z-Score Model Selection Criteria\n"]
    if context_info:
        industry_val = context_info.get("Industry")
        sic_val = context_info.get("SIC Code")
        if industry_val and sic_val and industry_val != "Unknown":
            lines.append(f"- **Industry:** {industry_val} (SIC {sic_val})")
        else:
            lines.append(f"- **Industry:** {industry_val or sic_val}")
        for k, v in context_info.items():
            if k in ("Industry", "SIC Code"):
                continue
            lines.append(f"- **{k}:** {v}")
        lines.append("")
    return lines


def _get_model_label_and_overrides(df, model, context_info):
    MODEL_LABELS = {
        "original": "Original Z-Score (Public Manufacturing, 1968)",
        "private": "Z′-Score (Private Manufacturing, 1983)",
        "private_mfg": "Z′-Score (Private Manufacturing, 1983)",
        "private_service": "Zʺ-Score (Private Non-Manufacturing, Book Equity, 1995)",
        "service": "Zʺ-Score (Public Non-Manufacturing, 1995)",
        "emerging": "EM-Score (Emerging Markets, mid-1990s)",
    }
    override_lines = []
    override_context = None
    if hasattr(df, "zscore_results") and df.zscore_results:
        override_context = getattr(df.zscore_results[0], "override_context", None)
        if override_context:
            override_lines.append("### Model/Threshold Overrides and Assumptions\n")
            for k, v in override_context.items():
                override_lines.append(f"- **{k}:** {v}")
            override_lines.append("")
    elif "override_context" in df.columns:
        oc = df["override_context"].iloc[0]
        if oc:
            override_context = oc
            override_lines.append("### Model/Threshold Overrides and Assumptions\n")
            for k, v in oc.items():
                override_lines.append(f"- **{k}:** {v}")
            override_lines.append("")
    model_name = None
    if hasattr(df, 'zscore_results') and df.zscore_results and hasattr(df.zscore_results[0], 'model'):
        model_name = df.zscore_results[0].model
    elif 'model' in df.columns:
        model_name = df['model'].iloc[0]
    else:
        model_name = str(model).lower()
    if not model_name:
        model_name = 'original'
    model_label = MODEL_LABELS.get(str(model_name).lower(), str(model_name))
    # Patch context_info if needed
    if context_info is not None:
        for idx, line in enumerate(override_lines):
            if line.strip().startswith('- **Model:**'):
                override_lines[idx] = f'- **Model:** {model_label} ({model_name})'
                break
    return model_label, model_name, override_lines


def _get_formula_and_threshold_section(model_name):
    from altman_zscore.computation.constants import MODEL_COEFFICIENTS, Z_SCORE_THRESHOLDS
    formula_lines = []
    threshold_lines = []
    x_labels = []
    x_cols = []
    coeffs = MODEL_COEFFICIENTS.get(model_name, MODEL_COEFFICIENTS['original'])
    thresholds = Z_SCORE_THRESHOLDS.get(model_name, Z_SCORE_THRESHOLDS['original'])
    coeff_map = [
        ("X1", coeffs.get("A", 0), "(Current Assets - Current Liabilities) / Total Assets"),
        ("X2", coeffs.get("B", 0), "Retained Earnings / Total Assets"),
        ("X3", coeffs.get("C", 0), "EBIT / Total Assets"),
        ("X4", coeffs.get("D", 0), "Equity / Total Liabilities"),
        ("X5", coeffs.get("E", 0), "Sales / Total Assets"),
    ]
    terms = []
    for x, coeff, desc in coeff_map:
        if coeff != 0:
            terms.append(f"{coeff}*{x}")
            x_labels.append((x, desc))
            x_cols.append(x)
    formula_str = "Z = " + " + ".join(terms)
    formula_lines.append(f"## Z-Score Formula Used\n")
    formula_lines.append(formula_str)
    for x, desc in x_labels:
        formula_lines.append(f"- {x} = {desc}")
    formula_lines.append("")
    threshold_lines.append("**Thresholds:**")
    threshold_lines.append(f"- Safe Zone: > {thresholds['safe']}")
    threshold_lines.append(f"- Grey Zone: > {thresholds['distress']} and <= {thresholds['safe']}")
    threshold_lines.append(f"- Distress Zone: <= {thresholds['distress']}")
    threshold_lines.append("")
    return formula_lines, threshold_lines, x_cols


def _get_missing_fields_section(df):
    lines = []
    if hasattr(df, "missing_fields") and df.missing_fields:
        lines.append(
            "> **Warning:** The following required fields were missing for one or more quarters: "
            + ", ".join(sorted(set(df.missing_fields)))
            + ". Z-Score components for these fields are omitted or estimated. Interpret results with caution."
        )
        lines.append("")
    elif hasattr(df, "zscore_results") and df.zscore_results:
        missing = set()
        for res in df.zscore_results:
            if hasattr(res, "missing_fields") and res.missing_fields:
                missing.update(res.missing_fields)
        if missing:
            lines.append(
                "> **Warning:** The following required fields were missing for one or more quarters: "
                + ", ".join(sorted(missing))
                + ". Z-Score components for these fields are omitted or estimated. Interpret results with caution."
            )
            lines.append("")
    return lines


def _format_number_millions(val):
    try:
        if val is None or val == "":
            return ""
        val = float(val)
        val_m = val / 1_000_000
        return f"{val_m:,.1f}"
    except ValueError:
        return str(val)


def _get_field_mapping_table(df):
    import tabulate
    mapping_rows = []
    mapping_header = ["Quarter", "Canonical Field", "Mapped Raw Field", "Value (USD millions)"]
    for idx, row in enumerate(df.iterrows()):
        _, row = row
        q = row.get("quarter_end")
        q_str = str(q)
        try:
            import pandas as pd
            dt = pd.to_datetime(q)
            q_str = f"{dt.year} Q{((dt.month-1)//3)+1}"
        except (ValueError, TypeError):
            pass
        field_mapping = row.get("field_mapping")
        if isinstance(field_mapping, str):
            try:
                import json
                field_mapping = json.loads(field_mapping)
            except Exception:
                field_mapping = {}
        if not isinstance(field_mapping, dict):
            field_mapping = {}
        for canon, mapping in field_mapping.items():
            mapped_raw = mapping.get("mapped_raw_field")
            val = mapping.get("value")
            mapping_rows.append([
                q_str,
                canon,
                mapped_raw if mapped_raw is not None else "",
                _format_number_millions(val),
            ])
        if idx < len(df) - 1:
            mapping_rows.append(["---", "---", "---", "---"])
    return tabulate.tabulate(mapping_rows, headers=mapping_header, tablefmt="github")


def _get_zscore_component_table(df, x_cols):
    import tabulate
    rows = []
    for _, row in df.iterrows():
        q = row.get("quarter_end")
        q_str = str(q)
        try:
            import pandas as pd
            dt = pd.to_datetime(q)
            q_str = f"{dt.year} Q{((dt.month-1)//3)+1}"
        except (ValueError, TypeError):
            pass
        z = row.get("zscore")
        comps = row.get("components")
        diag = row.get("diagnostic")
        if isinstance(comps, str):
            try:
                import json
                comps = json.loads(comps)
            except Exception:
                comps = {}
        if not isinstance(comps, dict):
            comps = {}
        row_vals = [q_str]
        for x in x_cols:
            val = comps.get(x)
            row_vals.append(f"{val:.3f}" if val is not None else "")
        row_vals.append(f"{z:.3f}" if z is not None else "")
        row_vals.append(diag or "")
        rows.append(row_vals)
    header = ["Quarter"] + x_cols + ["Z-Score", "Diagnostic"]
    if "consistency_warning" in df.columns:
        header.append("Consistency Warning")
        for i, (_, row) in enumerate(df.iterrows()):
            warning = row.get("consistency_warning")
            rows[i].append(warning if warning else "No issues")
    return tabulate.tabulate(rows, headers=header, tablefmt="github")


def _get_chart_md(context_info, out_base):
    import os
    ticker = context_info.get("Ticker") if context_info else None
    out_path = None
    if out_base:
        from altman_zscore.utils.paths import get_output_dir
        out_path = get_output_dir(relative_path=f"{out_base}_zscore_full_report.md")
    chart_md = None
    if ticker and out_path:
        github_chart_path = f"zscore_{ticker}_trend.png"
        local_chart_path = os.path.abspath(os.path.join("output", ticker, f"zscore_{ticker}_trend.png"))
        out_dir = os.path.abspath(os.path.dirname(out_path))
        chart_dir = os.path.dirname(local_chart_path)
        if out_dir == chart_dir:
            chart_md = f"\n![Z-Score and Price Trend Chart]({github_chart_path})\n"
        else:
            rel_chart_path = os.path.relpath(local_chart_path, out_dir).replace("\\", "/")
            chart_md = f"\n![Z-Score and Price Trend Chart]({rel_chart_path})\n"
        chart_md += "\n"
        if os.path.exists(local_chart_path):
            chart_md += f"*Figure: Z-Score and stock price trend for {ticker.upper()} (see output folder for full-resolution image)*\n"
        else:
            chart_md += f"*Figure: Z-Score and stock price trend for {ticker.upper()} (image not available yet; will be generated after analysis)*\n"
    return chart_md


def _get_llm_commentary_section(lines, context_info):
    try:
        from altman_zscore.api.openai_client import get_llm_qualitative_commentary
        import os
        prompt_path_new = os.path.abspath(
            os.path.join(os.path.dirname(__file__), "..", "prompts", "prompt_fin_analysis.md")
        )
        prompt_path_legacy = os.path.abspath(
            os.path.join(os.path.dirname(__file__), "prompts", "prompt_fin_analysis.md")
        )
        if os.path.exists(prompt_path_new):
            prompt_path = prompt_path_new
        elif os.path.exists(prompt_path_legacy):
            prompt_path = prompt_path_legacy
        else:
            raise FileNotFoundError(
                f"Could not find prompt_fin_analysis.md in either src/prompts/ or src/altman_zscore/prompts/. Checked: {prompt_path_new}, {prompt_path_legacy}"
            )
        with open(prompt_path, "r", encoding="utf-8") as f:
            llm_prompt = f.read()
        context = "\n".join(lines)
        full_prompt = f"{llm_prompt}\n\n---\n\n{context}"
        ticker = context_info.get("Ticker") if context_info else None
        llm_commentary = get_llm_qualitative_commentary(full_prompt, ticker=ticker)
        return llm_commentary.strip() + "\n"
    except Exception as exc:
        return f"> [LLM commentary unavailable: {exc}]"


def report_zscore_full_report(
    df,
    model,
    out_base=None,
    print_to_console=True,
    context_info=None,
    model_obj=None,
    calibration=None,
):
    lines = []
    lines += _get_report_intro_and_title(context_info)
    lines.append(_get_script_version())
    lines += _get_context_section(context_info)
    model_label, model_name, override_lines = _get_model_label_and_overrides(df, model, context_info)
    lines += override_lines
    formula_lines, threshold_lines, x_cols = _get_formula_and_threshold_section(model_name)
    lines += formula_lines
    lines += threshold_lines
    lines += _get_missing_fields_section(df)
    # Field mapping table is generated but not appended to report (per original logic)
    # mapping_table_str = _get_field_mapping_table(df)
    table_str = _get_zscore_component_table(df, x_cols)
    import os
    lines.append("\n\n---\n\n# Graphical View of the Z-Score Analysis\n")
    chart_md = _get_chart_md(context_info, out_base)
    if chart_md:
        lines.append(chart_md)
    lines.append("\n## Z-Score Component Table (by Quarter)")
    lines.append(table_str)
    lines.append(_get_llm_commentary_section(lines, context_info))
    lines.append("\n\n---\n\n# Appendix\n")
    report_md = "\n".join(lines)
    if out_base:
        out_path = get_output_dir(relative_path=f"{out_base}_zscore_full_report.md")
        with open(out_path, "w", encoding="utf-8") as f:
            f.write(report_md)
        print_info(f"Full Z-Score report saved to {out_path}")
    if print_to_console:
        print(report_md)
    return report_md


